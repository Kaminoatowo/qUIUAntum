# I'm trying to build a tool set fordoing quantum computing in UIUA
# Inspired by the work done for quAPL by
# Santiago NÃºÃ±ez-Corrales, PhD (nunezco2@illinois.edu)
# Marcos Frenkel (marcosf2@illinois.edu)
# Bruno de Abreu (babreu@illinois.edu)
# National Center for Supercomputing Applications

# -----------------------------------------------------------

# -----------------------------------------------------------
# Part 0: Math functions
---Math
  ScalarProduct â† /+Ã—
  Conjugate â† âœÂ°â„‚Â¯
  Dagger â† Conjugate
  Normalize â† Ã·âˆš:âŸœ(ScalarProductâŸœDagger) # this works for ket vectors
  Exp â† â¿:e
  RoundEsa â† Ã— âŸœ(>0.000001âŒµ)
  SinAndCos â† âˆ©RoundEsa âŠƒ(âˆ¿)(âˆ¿+Î·)
  RHCD â† Ã·2(â„‚1 1)  # Right half complex diagonal
  LHCD â† Ã·2(â„‚Â¯1 1) # Left half complex diagonal
  OvSqTwo â† Ã·âˆš2
  RealPart â† â—ŒÂ°â„‚
  ImPart â† â—Œ:Â°â„‚
  SignToBit â† Ã·2+1Â±
  MixOrPure â† =1âŠ¢/+
---

# -----------------------------------------------------------
# Part I: Single qubit manipulation (Sng)
---Sng
  # Ground state |0>âŒˆ
  Qground â† â†¯2_1 1_0
  # Excited state |1>
  Qexcited â† â†¯2_1 0_1
  # Superposition starter
  Qstarter â† [Qground Qexcited]
  # Linear superposition of amplitudes
  # Input: the relative amplitudes for the G and E states
  Qsuper â† Math~Normalize Math~ScalarProduct Qstarter âŠ‚
  # Bloch state
  # Input: Bloch angles, in order theta and phi
  # theta in [0, Ï€]
  # phi in [0, Ï„]
  Bloch â† Math~ScalarProduct Qstarter Ã—âŠ‚1â„‚âŠƒâˆ¿(âˆ¿+Î·):âŠ‚âŠƒ(âˆ¿+Î·)âˆ¿Ã·2
  # Projector operator to 0
  Pground â† â†¯2_2 1_0_0_0
  # Projector operator to 1
  Pexcited â† â†¯2_2 0_0_0_1
---

# -----------------------------------------------------------
# Part II: Quantum gates (gates)
---Gates
  # Identity gate
  I â† â†¯2_2 1_0_0_1
  # Global phase
  # Input: phase in [0, Ï„]
  G â† Ã—I Math~Exp Ã— i
  # Pauli X gate
  X â† â†¯2_2 0_1_1_0
  # Pauli Y gate
  Y â† â†¯2_2 0_(Â¯i)_i_0
  # Pauli Z gate
  Z â† â†¯2_2 1_0_0_Â¯1
  # S gate - sqrt Z
  S â† â†¯2_2 1_0_0_i
  # V gate - sqrt X
  V â† Ã·2 â†¯2_2 (â„‚ 1 1)_(â„‚ 1 Â¯1)_(â„‚ Â¯1 1)_(â„‚ 1 1)
  # Hadamard gate
  H â† Ã·âˆš2 â†¯2_2 1_1_1_Â¯1
  # T gate - sqrt S
  T â† â†¯2_2 1_0_0_(Math~Exp Ã— i Ã·4 Ï€)
  # Phase shift gate
  # Input: phase in [0, Ï„]
  P â† â†¯ 2_2 âŠ‚ 1_0_0 Math~Exp Ã— i
  # Rotation around X axis
  # Input: phase in [0, Ï„]
  Rx â† â†¯2_2âŠ‚âŸœâ‡ŒâŠ‚:Ã— Â¯ i Math~SinAndCos Ã·2
  # Rotation around Y axis
  # Input: phase in [0, Ï„]
  Ry â† â†¯2_2âŠ‚:âŸœ(âŠ¢â‡Œ)âŠ‚âŠ‚:âŸœÂ¯Math~SinAndCos
  # Rotation around Z axis
  # Input: phase in [0, Ï„]
  Rz â† â†¯2_2 â‡ŒâŠ‚â‡ŒâŠ‚ 0_0 âˆ©Math~Exp âŸœÂ¯Ã— i Ã· 2
  # Generalized rotation
  # Input: theta phi lamba
  # theta in [0, Ï€]
  # phi in [0, Ï„]
  # lamda in [0, Ï„]
  ---Um
    MulExtreme â† âˆ˜âŠ™âŠ™âˆ˜ Ã—
    ForkBetween â† âŠ™âŠ™âŠƒÂ¯âˆ˜âŸœÃ—
    JoinStack â† âŠ‚:âŠ™âŠ‚: âŠ™âŠ™âŠ‚
    Call â† JoinStack ForkBetween MulExtreme Math~SinAndCosÃ·2âŠ™(Math~Exp Ã— i +)âŠ™âŠ™âŸœ(Math~Exp Ã— Â¯ i) # SinAndCosÃ·2
  ---
  U â† â†¯2_2 Um
  # Controlled NOT gate
  CNOT â† â†¯4_4 [1_0_0_0
               0_1_0_0
               0_0_0_1
               0_0_1_0]
  # Square root of NOT gate
  SqNOT â† Ã·2 â†¯2_2 + 1_1_1_1 i_(Â¯i)_(Â¯i)_i
  # XNOR gate
  XNOR â† â†¯4_4 [0_1_0_0
               1_0_0_0
               0_0_1_0
               0_0_0_1]
  # CY
  CY â† â†¯4_4 [1_0_0_0
             0_1_0_0
             0_0_0_(Â¯i)
             0_0_i_1]
  # CZ
  CZ â† â†¯4_4 [1_0_0_0
             0_1_0_0
             0_0_1_0
             0_0_0_Â¯1]
  # Controlled phase
  # Input: phase in [0, Ï„]
  CP â† â†¯4_4 âŠ‚ 1_0_0_0_0_1_0_0_0_0_1_0_0_0_0 Math~Exp Ã— i
  # Controlled phase S
  CS â† â†¯4_4 [1_0_0_0
             0_1_0_0
             0_0_1_0
             0_0_0_i]
  # XX interaction
  # Input: phase in [0, Ï„]
  ---XXm
    Prepare â†š Ã— Â¯ i Math~SinAndCos Ã·2
    XOOY â†š âŠ‚:âŠ‚ 0_0
    OYXO â†š â†»2
    Reorder â†š âŠ‚:âŠ‚âŠ‚âˆ©(â‡Œ.):
    Call â† ReorderâŸœOYXO XOOY Prepare
  ---
  XX â† â†¯4_4 XXm # (âŠ‚â‡ŒâŠ‚ 0_0)
  # YY interaction
  # Input: phase in [0, Ï„]
  ---YYm
    Prepare â†š âŠƒÂ¯âˆ˜(Ã— i) Math~SinAndCos Ã·2
    DupLast â†š âŠ™âŠ™.
    XOOYp â†š âŠ‚:âŠ‚ 0_0
    Move â†š âŠ™:
    OYmXO â†š âŠ‚ 0â‡ŒâŠ‚âŠ‚ 0
    Reorder â†š âŠ‚:âŠ‚âŠ‚âˆ©(â‡Œ.)
    Call â† Reorder âŠ™XOOYp â‡ŒOYmXO Move DupLast Prepare
  ---
  YY â† â†¯4_4 YYm
  # ZZ interaction
  # Input: phase in [0, Ï„]
  ---ZZm
    Prepare â†š âˆ©Math~Exp âŸœÂ¯Ã— i Ã·2
    TwoZeros â†š âˆ©(âŠ‚ :0_0)
    XmOOO â†š âŠ‚ :0
    OXpOO â†š â‡ŒâŠ‚ 0
    Reorder â†š âŠ‚:âŠ‚âŠ‚âˆ©(â‡Œ.):
    Call â† Reorder XmOOO : OXpOO TwoZeros Prepare
  ---
  ZZ â† â†¯4_4 ZZm
  # XY Interaction (XX + YY)
  # Input: phase in [0, Ï„]
  ---XYm
    Prepare â†š Ã— Â¯ i Math~SinAndCos Ã·2
    OneVec â†š 1_0_0_0
    OYXO â†š âŠ‚ 0â‡ŒâŠ‚âŠ‚ 0
    Reorder â†š âŠ‚:âŠ™âŠ‚
    Call â† Reorder âŠƒâ‡Œâˆ˜OneVec âŠ‚âŸœâ‡ŒOYXO Prepare
  ---
  XY â† â†¯4_4 XYm
  # Double Controlled NOT
  DCNOT â† â†¯4_4 [1 0 0 0
                0 0 1 0
                0 0 0 1
                0 1 0 0]
  # SWAP
  Swap â† â†¯4_4 [1 0 0 0
               0 0 1 0
               0 1 0 0
               0 0 0 1]
  # Imaginary SWAP
  ImSwap â† â†¯4_4 [1 0 0 0
                 0 0 i 0
                 0 i 0 0
                 0 0 0 1]
  # Fermionic SWAP
  FSwap â† â†¯4_4 [1 0 0 0
                0 0 1 0
                0 1 0 0
                0 0 0 Â¯1]
  # Square root SWAP
  SqSwap â† â†¯4_4 [1_0_0_0
                 0_Math~RHCD_Math~LHCD_0
                 0_Math~LHCD_Math~RHCD_0
                 0_0_1_1]
  # Square root imaginary SWAP
  SqImSwap â† â†¯4_4 [1_0_0_0
                   0_(Math~OvSqTwo 1)_(Math~OvSqTwo i)_0
                   0_(Math~OvSqTwo i)_(Math~OvSqTwo 1)_0
                   0_0_0_1]
  # Swap raised to the a-th power
  # Input: a-th power
  ---AthSwapm
    Prepare â†š âˆ©(Ã·2+1)âŠƒÂ¯âˆ˜ Ã— i âˆ¿
    AddZeros â†š â‡ŒâŠ‚ 0â‡ŒâŠ‚ 0
    OneVec â†š 1_0_0_0
    Call â† âŠ‚ OneVec â‡Œ âŠ‚ OneVec âŠ‚â‡Œ. AddZeros âŠ‚ Prepare
  ---
  AthSwap â† â†¯4_4 AthSwapm
  # Fredkin (Control SWAP)
  FRK â† â†¯8_8 [1 0 0 0 0 0 0 0
              0 1 0 0 0 0 0 0
              0 0 1 0 0 0 0 0
              0 0 0 1 0 0 0 0
              0 0 0 0 1 0 0 0
              0 0 0 0 0 0 1 0
              0 0 0 0 0 1 0 0
              0 0 0 0 0 0 0 1]
  # Toffoli (Doubly-controlled NOT)
  TOF â† â†¯8_8 [1 0 0 0 0 0 0 0
              0 1 0 0 0 0 0 0
              0 0 1 0 0 0 0 0
              0 0 0 1 0 0 0 0
              0 0 0 0 1 0 0 0
              0 0 0 0 0 1 0 0
              0 0 0 0 0 0 0 1
              0 0 0 0 0 0 1 0]
  # Generalized controlled gate with k-qubit controls
  # Input: number of (preceding) control qubits
  #        gate
  ---GCTRm
    ID â† â†¯ âŠ‚.:âŠ‚ 1 Ã— 0 â‡¡.
    GetDim â† Ã— 2+ â‚™2 â§»
    ZerosMat â† â†¯ : 0 âŠ‚.Ã— 2 # âŠ¸â§»
    Call â† [Â¯2_Â¯2 Â¯2_Â¯1 Â¯1_Â¯1 Â¯1_Â¯2] ID GetDim,
    # not finished yet
  ---
  GCTR â† GCTRm
---
# -----------------------------------------------------------
# Part III: Quantum circuits (Circ)
---Circ
  # New ground state register
  # Reg â† â†¯âŠ‚:1 âŸœâ‡¡âŸœ(â†¯ : Sng~Qground âŠ‚ :2_1)
  Reg â† â‰â†¯âŠ‚2âŸœ(âŠ‚â†¯âŠ‚:1 âŸœâ‡¡)âŸœ(â†¯ : â–¡Sng~Qground âŠ‚ :1)
  # Obtain a subregister using qubit indices
  PickN â† âŠ‚âŸœ(âŠ¡1âŠ¡)
  PickNReorder â† :PickN:
  Subregister â† âˆ˜ # â†¯:âŸœ(âŠ‚âŠ‚ 1. Ã· 2 â–³)join PickNReorder âŸœ(PickNReorder) # âŠ‚âŸœ(âŠ¡1âŠ¡)
  # Thread a set of Hilbert space entities into a larger Hilbert space entity
  # Thread a (filtered) register into a vector state
  # Thread a gate set into a single operation
  # Unthread a vector state and produce a new register
  # Build a table with the full binary representation of (2^n, 1) indices of an C^n vector
  # Map a qubit reordering into the tensor product row reordering
  # Apply a stage to a current vector state representing n qubits, with the given gates and
  # a stated gate-dependent reordering (reordering a C^2 vector is less expensive than the gates)
  # Replaces every occurance of 0 with âº in âµ. âº must be of shape 1.
  # Replaces every instance of 0 in âµ with the identity matrix
---
# -----------------------------------------------------------
# Part IV: Show, or Representation of qubits
---Show
  # Show a quantum state
  # Input: quantum state
  ---Qm
    WhichSign â†š â¨¬("-")("+")
    GetSign â†š âŠƒ(WhichSign Math~SignToBit Math~RealPart âŠ¢ â‡Œ)(â¨¬Â¯âˆ˜ âŠ¸(â‰¥0 Math~RealPart))
    MixFormat â†š $"(_) |0âŸ© _ (_) |1âŸ©"
    Mix â†š MixFormatâŠƒ(âŠ¢ Math~ScalarProduct Sng~Qground)(GetSignâŠ¢ Math~ScalarProduct Sng~Qexcited)
    PureFormat â†š âŠ¢ â¨¬("|1âŸ©")("|0âŸ©")
    Pure â†š PureFormat Math~RealPart âŠ¢
    PureOrMixture â†š â¨¬(Mix)(Pure)âŠ¸Math~MixOrPure
    Call â† PureOrMixture # 
  ---
  Q â† Qm
  # Shows a  state as a classical bit or a mixture
  ---Bm
    PureFormat â†š âŠ¢ â¨¬("1")("0")
    Call â† â¨¬("ğœ‘")(PureFormat Math~RealPart âŠ¢)âŠ¸Math~MixOrPure
  ---
  B â† Bm
---
# -----------------------------------------------------------
# Show
---test
Regiii â† Circ~Reg 3
# Circ~Subregister Regiii 0 1
# Gates~GCTR 1 Gates~X
# Show~Q Â°â–¡âŠ¡1âŠ¡1 Regiii
Â°â–¡âŠ¡1âŠ¡1 Regiii
---
